> 우아한 테크러닝 3기 첫 세션을 정리해보았읍니다..
> 정리의 편의를 위해 혹은 잘못 알아들어서 실제 세션의 내용과 조금 다르게 정리 되어있을 수 있읍니다..

## 🤔 모두의 고민

### 나는 잘 하고 있나?

코드를 짤 때 정답이 한 가지로 정해져 있는게 아니라 방법이 수 만가지라서 잘 하고 있나에 대한 고민을 많이 하게 되죠 ㅠㅠ

### 네트워킹

나보다 연차가 있는 개발자와 친분이 있었으면 하는 마음.. 다들 똑같잖아여..?!

### 코드 품질, 아키텍처, 적정기술

나는 잘 하고 있나에 대한 물음의 확장판인 것 같은데 이러한 고민은 특히나 신입개발자들이 많이 가지는 고민쓰
특히나 개발자 면접 단골 질문인 '프로젝트에서 이 기술을 왜 썼나?'에 대한 질문에 대해 진지하게 생각해 본적 있는지..?! 나는 아직까진 없다 ㅠㅠ
내가 프로젝트에 사용할 기술 스택을 결정할 때도 제대로 고민해서 선택했느냐에 대한 답변을 할 수 있을 정도로 진지하게 고민을 해야할 필요가 있다.

### 도구

예전엔 `hello world` 를 콘솔창에 띄우기 위해 한 6개월 투자해서 바닥부터 개발을 해야 했다면
현재는 도구가 많이 발전해서 어떤 라이브러리를 써야하는 지 등의 고민을 하고 있다.
개발에서의 쓰이는 시간 중 70~80%는 도구를 익히는 데 쓰게 된다.

## 세션의 목표

앞으로의 세션에서

- 상태를 어떻게 관리하고 다룰 것인가
- runtime 환경 뿐만 아니가 개발환경도 어떻게 다룰 것인가

등의 이야기를 다루게 될 것 같다!

---

이제 세션 시작!

> 첫 날이라 진도를 바짝 나가진 못했지만, 좋은 얘기를 넘 많이 해주셨다!
> 세션 진행자인 김민태님 뿐만 아니라 채팅창에서도 활발한 교류가 이루어졌다.

## TypeScript

#### type

```
let foo = 10;
```

위의 코드가 typescript에서 에러가 나지 않는 이유!
foo라는 변수를 만들면서 바로 10이라는 값을 대입하고 있고, ts 컴파일러가 10이 어떤 타입인지 알기 때문에 `타입 추론`을 통해 foo의 타입을 number로 정하는 것이다.

하.지.만.

```
let foo : number = 10;
foo = false;

```

다른 타입을 넣을 경우 에러가 남.

```
let age : number = 10;
let weight : number = 72;
```

원시타입의 장점은 일반화 되어있어서 **다양한 용도**로 쓸 수 있다.
현실 세계에서 쓰는 단위를 의미화 하지 못하지만, 물리적인 값으로 number는 다양하게 쓰일 수 있다.
이는 재활용성에서 보면 정말 좋다.

하.지.만.

조금 더 타입에 의미를 부여하고 싶을땐 단점이 된다.

### type alias

```
let age: Age = 10;
```

여기에 number라는 type 대신에 Age 타입을 쓰고 싶을 땐

```
type Age = number; // 오른쪽에 있는 타입의 별명을 Age로 이름 붙여 준 것임. 대입이 아님.
let age : Age = 10;
```

이것이 바로 `type alias` 이다.
number라는 type을 쓰는 게 더 간단한데, 왜 alias를 쓰는가에 대한 답변은
Age라는 type을 지정해서 쓰는 게 더 명시적 다른 말로 context적이기 때문이다.
(채팅창에서 답변해주신 분들 감사합니다!)

암묵적인 것 보다는 명시적인 것이 훨씬 좋다.
타입 스펙을 만드는 개발자들도 비슷한 생각을 하고 있고, 또 이것이 요즘의 트랜드이다!

몇 십년 전에는 코드가 암호처럼 보여도 잘 짜여져 보였지만,
요즘은 짧고 난해한 코드보다 길더라도 명시적인 코드를 선호하는 흐름이 있다.

대표적으로 자바스크립트 문법이 해마다 개선되는 것도 예전 스펙에서 암묵적인 부분을 명시적으로 확장될 수 있도록 바꿔 나가려는 이유 때문이다.

```
function bar() {
	arguments
	return 0;
}

bar(10,20)

```

위의 코드에서 함수를 실행시키기 전까진 함수 내부에 인자가 아무것도 없기 때문에 가변인자를 받는지 모른다.
이는 다시 말하면 암묵적이라는 것!

그.래.서.

```
function bar(...args) {
	return 0;
}
```

이런 측면에서 나온 문법이 바로 spread operator이다!
이런 이유가 있었다니 몰랐다리~
spread는 워낙 기능이 많아서 언제 한번 정리하고 넘어가고 싶다 하하

### interface

```
type Age = number;

interface Bar {
    age: Age;
    name: string;
}

const bar: Bar = {
    age: 10,
    name: "Kim",
};
```

인터페이스와 타입은 비슷한데
왜 이걸 쓰는지에 대한 명쾌한 해법은 리액트에서 직접 쓰면서 추후 알려주실 것 같다!

나도 지금 인터페이스 쓰고 있는데 그냥 객체형이면 인터페이스를 쓴다.. 정도로만 알아서
이후의 세션이 넘넘 기대가 된다!

끄적끄적... (일단 나중에 보충하기 위해 적은 내용)

> 컴파일 타임에만 작동되는 요소(type Alias, generic, interface), 런타임까지 가는 경우(에러를 잡아낸다.)
> ts의 장점 : (타입 체크 등 ) 컴파일 타입에 중요한 것.

## CRA에 TS 설치하기

`npx create-react-app woowahan --template typescript`

template 붙이면 tsconfig가 자동으로 생성되는 것 같다..? 맞나?!
`--template` 은 붙여 본 적이 없어서 신기쓰

다양한 프론트 스펙을 가진 분들을 위해 리액트의 props부터 찬찬히 설명해주셨는데..
몰랐던 점을 이렇게 알아간다 ㅠㅠ

### babel

![](https://images.velog.io/images/dooreplay/post/a0e15bbb-6812-465c-9134-7d2665cf620d/image.png)

개발자들이 오른쪽 문법대로 개발하면 힘드니까 transpiler를 만들어서 일을 쉽게 하는 것!
이 babel의 존재 이유!
근데 컴파일 되기 전의 오른쪽 코드까지 알아야 나중에 좋다고 하니, 이 부분은 좀 더 파봐야겠다.

**props가 왜 객체 형태인지도 babel 구조를 보면 알 수 있다.**
**와..**

![](https://images.velog.io/images/dooreplay/post/23b699a3-9f5b-4632-9177-86a5a8db3c17/image.png)

증말 띵~~~ 했다 ㅋㅋㅋㅋㅋㅋㅋ
이래서 객체형태였구나!

## 상태관리

### redux

민태님은 리덕스를 오래 써서 리덕스가 편하다고 하셨는데
많은 분들이 간단함 때문에 어려워 한다고 했다
(사실 간단하다고 조차 생각을 못했..)

간단한 형태로 복잡한 거 만드는게 원래 어려운 거고, 예시를 하나 들어주셨다.

> 어른한테 심부름 시키는 건 쉽다. 간단한 언어로 심부름 시킬 수 있다.
> 하지만 유치원생한테는 심부름 시키는 게 어렵다. 기능이 없어서 ㅋㅋㅋㅋㅋ

넘나 찰떡같은 설명!!

### mobx

mobX는 리덕스의 대체품이라기 보다는 1:1로 비교하기 보다는 상태도 다르고 상태를 바라보는 관점도 다르다. 처음 쓰면 굉장히 편한데, 단순한 애는 단순한 형태를 취하는 이유가 있다.
단순한 형태를 가지면 그걸 만든 사람이 원하는 형태도 결과물을 가이드하기 쉽기 때문

결국 mobX와 redux는 js와 ts 와의 관계성과 비슷하다.

왜 강타입 언어를 선호할까? 결국은 js로 변환되서 js가 읽히는건데!
js가 가지고 있는 유연성이 장점이지만 개발자의 실수할 여지 등의 단점이 있다.
각각의 장단점을 잘 살려서 선택해야 하는데 mobX도 마찬가지이다.

mobX를 쓰면서도 어떤 부분을 실수할 수 있는 부분인지 아닌지를 잘 고려해야 하고,
간단한 앱을 mobX로도 redux로도 개발해보면서 차이를 비교해보라고 하셨다 크~
