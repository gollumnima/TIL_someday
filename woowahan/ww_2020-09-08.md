## 날아갈까봐 저장쓰

지난 시간에 리덕스를 자바스크립트로 구현했던 것처럼
이번 시간에는 리액트를 자바스크립트로 구현하는 것이 강의 목표!

> - 리액트에 대한 기본적인 부분
> - 리액트 구현해보기

## 리액트

(도입부터 띵언으로 스타트!)
공식문서 보고 학습하다 보면 지식의 넓이가 넓어질 수 있다.
하지만, 깊이보다 넓이를 추구하다 보니 자꾸만 이것저것 학습하려고 하고 그러다 보면 쉽게 지친다.

지금 나의 상태가 약간 그런거 같은데.. 어떻게 이렇게 잘 아시죠 ㅠㅠ

어찌됐든 우리는 개발 소비자로 남는것보다 라이브러리 하나를 공부하더라도 **어떤 원리로 작동이 되고 있는지 깊이 파봐야** 10년 뒤의 연봉이 달라진다고 하셨다 크으~

모든 라이브러리나 프레임워크의 사용법은 공식문서 보면 참 잘 나와있다.
우리가 공부하면서 파악해야 하는 것은 why.
하지만 왜 그렇게 사용해야 하는가에 대한 내용은 공식문서에 나오지 않는다.

그래서 리액트의 사상을 이해하는 데 문제가 없을만한 핵심적인 부분을 짚고 넘어가는 것이 우리의 목표!

### 시작

리액트를 조금이라도 공부해봤던 사람이라면
index.html 파일 안에 아래의 id가 root인`div`가 존재한다는 사실을 알 것이다.

```
<div id="root" />
```

아래의 list라는 데이터를 이제 ui로 그려보자.

```
const list = [
  { title: 'React에 대해 알아봅시다' },
  { title: 'Redux에 대해 알아봅시다' },
  { title: 'TypeScript에 대해 알아봅시다' },
];

const rootElement = document.getElementById('root');

function app() {
  rootElement.innerHTML = `
  <ul>
  ${list.map((item) => `<li>${item.title}</li>`).join('')}
  </ul>`;
}

app();

```

코드펜에 복붙했을 때 바로 좌측과 같은 목록이 만들어진다.
여기서 잠깐..

> 🙋🏻‍♀️ **리빙포인트!**!
> 아키텍처적으로 가장 쉽게 할 수있는 일 : **이름 잘 짓기**
> 또 다른 중요한 포인트 : **같은 것끼리 묶고 다른 것들읕 분리하자**

나머지 아키텍처적인 원칙들은 20%를 차지할 수있음. 이름짓기가 팔할이다!
너무 높은 수준의 무언가를 추구하다가 기본적인 것을 소홀히 하는 경우가 많다
그래서 이름 짓는게 참 중요하다.

또, 한번만 만들어놓고 절대 변하지 않는 앱이라면 코드에 대한 공수가 많이 들지 않는다. 하지만 문제는 끊임없이 변한다는 점이다.
한 달전에 만들었던걸 한달 뒤에 고치려고 하면 생각이 안남. 왜냐. 까먹어서!
코드를 짜다보면 어떤 것이 좋은 아키텍처인가에 대한 고민을 하게 되는데,
결국 같은 것끼리 묶고 다른 것들은 분리하자는 결론이 도출된다.

(다시 본론으로 돌아와서..)

위의 코드에서 app 함수의 모양새를 약간 바꿔줘야 한다.
현재 상태론 바깥쪽 dependency에 영향을 받기 때문에!

```
function app(items) {
  rootElement.innerHTML = `
  <ul>
  ${items.map((item) => `<li>${item.title}</li>`).join('')}
  </ul>`;
}

app(list);

```

짠~ 순수 함수로 만들어주었음

> 🙋🏻‍♀️ **다시 돌아온 리빙포인트!**!
> 추상화레벨이 낮다 👉 복잡도가 올라간다 👉 수정하기가 힘들어진다.

리얼돔의 api가 너무 low레벨(추상화수준이 낮음)이라 그걸로 앱의 ui를 다루다 보면 필연적으로 복잡도가 올라가게 된다. 그 말인 즉슨, 수정하기가 힘들어진다는 것이다.
리얼돔을 직접적으로 다루는 라이브러리들도 나중에 복잡도가 높아지는걸 피할수없음
ex) 제이쿼리

제이쿼리 자체가 나쁘다기 보단 우리가 다룰 앱이 복잡하기 때문에 적절하지 않다고 한다.
제이쿼리가 단순히 옛날기술이라 나쁘다고만 생각했는데, 앞으론 이러한 이유로 쓰지 않는다고 당당하게 말할 수 있게 되었다 😎

### 리액트의 컨셉

정말 간단하다고 함(민태님피셜)

A와 B가 있는데 A는 약간 까탈스러운 편.
A를 다루다 보면 어느새 B도 까다로워짐.

이에 대한 해결책으로 **중간에 쉬운 구조**를 하나 만들어서 좁 더 복잡한 구조A와 연결을 해서 다루자는 것.
대표적인 예시가 바로 브라우저이다.

(민태님의 아이패드 그림을 소심하게 캡쳐 해보았다)

브라우저에 문자열을 보내기 위해 우리는 html태그를 쓴다.
원래 문자열은 구조가 없고 순수 데이터이기 때문에 다루기 어려운데,
다루기 쉬운 구조로 변환하고(DOM TREE) 우리는 그것을 내보낸다.

이러한 컨셉으로 만든 게 바로 리액트인 것이다!

자바스크립트에 DOM을 직접 연결하면 복잡하니까
**`자바스크립트 👉 VDOM 👉 DOM`** 형식으로 연결한 것..!

리액트 팀이 어느날 하늘에서 계시를 받고 유레카 외쳐서 새로운 것을 창조해낸게 아니라 결국은 브라우저 작동원리와 비슷하게 접근 한 것이다!

### jsx의 탄생

**`자바스크립트 👉 VDOM`** 이렇게 넘어가는 과정이 쉽다고 했는데
babel이 컴파일하기 전의 모습대로 해야 한다면 아무도 개발하지 않을 것이다.
그래서 마크업 하듯이 편하게 jsx를 만들어 냈음
(처음엔 모양이 이상해서 욕먹었다고 한다 와..)

return문 안이 html이라고 생각하고 마크업을 해보면

```
function App() {
  return (
    //여기가 html이다 생각하고 마크업을 해보자
    <div>
      <h1>Hello?</h1>
      <ul>
        <li>React</li>
        <li>Redux</li>
        <li>TypeScript</li>
        <li>MobX</li>
      </ul>
    </div>
  );
}
```

이러한 모양새가 나오는데, 여기서 html태그 하나 하나가 컴포넌트라고 생각하면 된다.

짠~ 바벨이 컴파일 하기 전의 우측 코드를 보면 상당히 복잡해 보인다.
우리는 jsx가 있기 때문에 간편하게 좌측처럼 코드를 짤 수 있는 것이다.

### 컴포넌트화

ul, li 태그는 너무 일반화 되어 있고 의미가 없다. 말 그대로 목록을 출력하는 태그인 것이다.
그래서 컴포넌트화 해서 이름을 부여하면 의미가 생기게 되서 좋다.
마크업을 보고 어떤 데이터가 어디에 들어있는지 확인 하지 않아도 딱 컴포넌트만 봐도 읽기 쉬워지기 때문!

**읽기 쉬워진다는 것은 곧 코드를 고치기 쉬워진다는 것** 🙌

```
import React from 'react';
import ReactDOM from 'react-dom';

function StudyList() {
  return (
    <div>
      <h1>Hello?</h1>
      <ul>
        <li>React</li>
        <li>Redux</li>
        <li>TypeScript</li>
        <li>MobX</li>
      </ul>
    </div>
  );
}

function App() {
  return (
    <div>
      <h1>Hello</h1>
      <StudyList />
    </div>
  );
}

ReactDOM.render(<App />, document.getElementById('root'));
```

컴포넌트 이름을 StudyList라고 붙여주니 조금 더 와닿는다.

### vdom의 작동원리

ui를 html로만 만들면 브라우저가 알아서 잘 그려준다.
그렇다면, 다루기 까다로운 문자열은 어떻게 할까?

```
  React.createElement('ul', {}, [React.createElement('li')]);
```

여기서 createElement는 버추얼 돔을 만드는 역할을 한다.
최종적으로 다 만들면 root컴포넌트에 appendChild 하는 식으로 가게 됨!
컴파일 되기 전의 우측 화면을 보자..

개발자는 생산자인 동시에 소비자기 때문에 예쁘고 편리한 것을 좋아한다.
매번 createElement를 쓰기 싫어서 vdom이 나오게 된 것이다!

```
const vdom = createElement('ul', {}, createElement('li', {}, 'React'));

```

> 🙋🏻‍♀️ **또 다시 돌아온 리빙포인트!**!
> babel에서 제일 상단에 `/* @jsx 메소드명*/` 를 입력해주면 createElement가 설정한 메소드명으로 바뀐다.

> 👀 **킹왕짱 중요한 포인트!**! 👀
> 자바스크립트는 컴파일 타임이 없었다. 스크립트 언어인데 컴파일 타임이 새로이 생긴거고, 우리는 이를 인지해야 한다. 지금이 컴파일 타임인지 런타임인지 구분해야 한다.

다음에 시간 날 때 런타임, 컴파일 타임에 대해 정리해보고 싶다...!

매 세션이 그렇지만 늘 새로운 내용이다. 짜릿해
하지만, 이건 다 바벨 플로그인-리액트 플러그인 문서에 다 나와있는 내용이라고 하신다...
언제 한번 바벨 사이트도 파봐야겠다 💪

[리액트 동작원리](https://pomb.us/build-your-own-react/)에 대해선 이 사람의 블로그도 정리가 잘 되어있다! 나중에 봐야지

문제점. type에 함수가 들어감.
바벨이 트랜스파일링 할때 소문자로 되어있는 애는 문자열로 인식
대문자로 되어있으면 처리방식이 다름! 아래의 그림 보시오!

리액트 빌트인 컴포넌트가 아닌 사용자 컴포넌트를 대문자로 해야하는 경우! 바로 이 때문에
사용자가 리턴한 함수가 컴포넌트로 인식되게 하기 위해!
문자열 가지고 하는거라 아주 심플하게 대소문자로 구분하게 함!

```
function createElement(type, props = {}, ...children) {
  if(typeof type === 'function') {
    return type.apply(null, [props, ...children])
    // 컨텍스트는 없으니까 널
    // 함수니까 타입을 호출할 수 있음
    // 인자가 들어갈 게 많은데 어떤 형식으로 들어갈지 모르니 type()라고 하면 위험할 수 있음
    // 그래서 어플라이 함수를 썼음
  }
  return { type, props, children };
}
```

```

function createElement(type, props = {}, ...children) {
  if (typeof type === 'function') {
    return type.apply(null, [props, ...children]);
    // 컨텍스트는 없으니까 널
    // 함수니까 타입을 호출할 수 있음
    // 인자가 들어갈 게 많은데 어떤 형식으로 들어갈지 모르니 type()라고 하면 위험할 수 있음
    // 그래서 어플라이 함수를 썼음
  }
  return { type, props, children };
}

function renderElement(node) {
  //vdom은 재귀일수밖에 없음
  // 루트가 있고 자식이 있고.. 자식이 언제 끝날지 몰라
  // 부모도 자식이랑 똑같이 생겼어! 전형적인 재귀호출 형태임
  const el = document.createElement(node.type);

  node.children.map(renderElement).forEach((element) => {
    el.appendChild(element);
  });
  // 노드에 칠드런이 있으면 맵을 돌려서 재귀!
  return el;
}

function render(vdom, container) {
  // vdom node를 인자로 받음
  CredentialsContainer.appendChild(renderElement(vdom));
}
```

## 리액트의 상태

```
import React from 'react';
import ReactDOM from 'react-dom';

// react컴포넌트 자체는 ui요소를 가지고 있지 않아서 반드시 랜더함수를 가지고 와야한다.

class Hello extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return <p>안녕하세요</p>;
  }
}

function App() {
  return (
    <div>
      <h1>상태</h1>
      <Hello />
    </div>
  );
}

ReactDOM.render(<App />, document.getElementById('root'));

```

리액트 초기엔

상태란? 어떤 변수가 있는데 값은 상태가 아님 값일 뿐임.
상태는 변할 수 있어야 함. 값은 기본적으로 immutable
그래서 값의 상태를 바꾸기 위해 변수라는 걸 만들었음
변수를 이용해 값이 변하는 것 같은 착각에 빠뜨리는 것 그게 바로 상태!

앱이라는 컴포넌트는 함수.
함수의 스코프가 생기기 떄문에 App이 두번째 세번째 랜더 될때마다 상태가 바뀔수가 없음.
초기의 리액트에선 함수형 컴포넌트는 상태를 가질 수 없다. 라고 했음

class는 상태를 자연스럽게 가질 수 있음.
자체 상태를 갖는다면 클래스 컴포넌트!
외부로부터 데이터를 받기로 하면 함수형 컴포넌트로 만들자는 게 컨벤션처럼 되어왔음.
초.기.에.는

기본적으로 라이프사이클이 있는데
상대적으로 함수형 컴포넌트는 호출되는 것 밖에 없어서 업데이트나 새로 만드는거나 똑같은 구조가 됨.
클래스 컴포넌트는 내부적으로 업데이트 되면 필요한 부분만 호출을 할 수 있게..
그래서 라이프사이클 메소드가 존재함.

- 라이프사이클 메소드들에 대한 설명은 생략! 공식문서에 잘 나와있으니깐!
- setState함수를 안 쓰고 직접 상태값을 변화하면 리액트가 감지할 수 없어서 백날 해도 안 바뀌는 것임
  (프록시를 쓰면 직접 대입해도 값을 변화시킬 수 있음)
- 클래스형에서 상태는 생성자 함수 안에 있어서 값을 변화

```
// 아래는 리액트 수도코드
const hello = new Hello();
vdom = hello.render();
if (hello.hasOwnProperty('componentDidMount')) {
  hello.componentDidMount();

  // 이런 구조를 deligate라고 함.
  // 부모가 제어하는 구조!
  // 적절한 타이밍에 적절한 메소드를 호출하게 됨. 그 적절한 타이밍을 라이프사이클이라고 함.
}
```

> 질의응답 중

vdom이 먼저 만들어지고 랜더되면 real dom이 생기는 순서임.
자기들이 자신있는 vodm 다루기 쉬우니까 그걸 vdom을 웹용으로 하면 그게 리액트, 앱용이면 네이티브
그래서 네이티브가 나온것임!

## 훅쓰

함수형 컴포넌트에서 상태를 가질 수 있는 스펙
useState는 기본적으로 배열을 리턴한다.
첫번째요소 값, 두번째요소 값을 고칠수있는 함수

useState 쓴 result 콘솔의 결과

const counter = result[0]
const setCounter = result[1];
이렇게 쓰면 너무 번거로우니깐

오른쪽이 배열이니까 배열 순서대로 옮김. 구조분해 할당! 디스트럭처링

1번째 가정
2번째 가정

이 값이 함수를 호출한건 알겠는데 이 앱이 다시 호출되었을때 카운터값이 어떻게 증가하지?
(그 얘기는 이전값을 기억해서 상태로서 작동하게 되는것일까?)

어떤방식이냐면
리액트가 컴포넌트를 만들때 createElement가 호출됨.
노드가 함수면 호출을 하는데..
App 잘보면 일단 함수! jsx 컴포넌트를 리턶라게 됨.
함수네-> 호출해야지 일단 알고있음
어떤 함수가 내부에서 호출할때 Hook 이라는 계열의 함수를 호출하면
App 함수 호출되고 특정 시점에 Hook 함수가 호출되면 아 이게 App에서 실행되었구나를 알 수 있음.
그래서 초기값을 클로저로(사실 클로저는 아님 배열임) 묶고있는 값을 index를 알고 있는 함수를 생성해서 배열에 넣는것임. 그래서 두번째 호출이면 초기값을 무시하고, 이전에 배열에 넣어둔 값을 호출하는것
훅은 그런 구조임!
useState 뿐만 아니라 useEffect 등 다 이런 구조로 만들어져있음

문제점..
component가 생성된 순서대로
훅을 매커니즘상 절대 이렇게 쓰면 안된ㄴ다는 내용이 공식문서에 있는데..

Hookr규ㅜ칙
최상위에서만 Hook을 호출해야 한다.
리액트 함수 내에서만 훅을 호출해야 한다 등 (리액트 컴포넌트를 인덱스로 잡음)

컴포넌트의 호출 순서에 따라 훅이 발동되기 때문에!!
엉뚱한 훅에 레퍼런스가 걸릴 위험이 있으니깐

그래서 다음번 호출할대

초기 리액트 훅 만든 개발자들이함수 안에서
전역으로 배열하나 두고 컴포넌트랑 인덱스 기준으로 잡고, 관리하자!
그래서 생성된 것이 훅스

함수형-> 조금 더 선언적인 프로그래밍이 가능하게 만드는 것!
